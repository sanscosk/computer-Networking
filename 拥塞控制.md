# 拥塞控制

## 拥塞概念：

拥塞（Congestion）是指在计算机网络中，由于网络资源不足或者网络流量过大而导致网络性能下降的现象。当网络中的数据流量超过了网络所能处理的容量时，就会出现拥塞。这可能导致数据包丢失、延迟增加、吞吐量降低等问题，影响通信的质量和效率。太多的源发送数据太多太快，导致网络无法处理。

**拥塞控制与流量控制的区别**：

1. **拥塞控制（Congestion Control）：**
   - **目标：** 主要目标是防止网络中的拥塞，确保网络资源的有效利用，以及防止网络过载。
   - **作用：** 通过监测网络的状态，检测拥塞的迹象，并采取相应的措施来减轻拥塞。这可能包括减缓数据的发送速率、丢弃一些数据包或采取其他措施来维持网络的稳定性和性能。
   - **位置：** 拥塞控制通常在网络层和传输层实现，涉及整个网络的资源管理。
2. **流量控制（Flow Control）：**
   - **目标：** 主要目标是确保在通信的两端之间的数据流动的平滑和有效，防止接收方无法处理发送方发送的太多数据而导致溢出。
   - **作用：** 通过协商和控制发送方的发送速率，确保接收方能够及时处理接收到的数据，避免缓冲区溢出。
   - **位置：** 流量控制通常在传输层实现，涉及通信的两端，即发送方和接收方之间的数据流控制。

拥塞控制关注的是整个网络的健康状态，以防止网络拥塞和资源过载，而流量控制关注的是通信的两端之间的数据流动，以确保接收方能够有效地处理发送方发送的数据。这两者在实现上有时可能有交叉，但它们的主要关注点和目标是不同的。

## 场景一：2个Sender, 和1个无限buffer的Router

![image-20231117103616658](C:\Users\nightgoodl\AppData\Roaming\Typora\typora-user-images\image-20231117103616658.png)

- 2个sender，2个receiver
- 1个router带无限buffer
- 输出链路的容量：R
- 没有重传（无限buffer不会丢包）

当发送速率在0〜R/2之间时，接收方的吞吐量等于发送方的发送速率，即发送方发送的所有数据经有限时延后到达接收方。然而当发送速率超过R/2时，它的吞吐量只能达到R/2。这个吞吐量上限是由两条连接之间共享链路容量造成的。

![Congestion scenario1 out.png](https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario1-out.png)

当发送速率接近R/2时（从左至右），平均时延就会越来越大。当发送速率 超过R/2时，路由器中的平均排队分组数就会无限增长，源与目的地之间的平均时延也会变成无穷大（假设这些连接以此发送速率运行无限长时间并且有无限量的缓存可用）。

![Congestion scenario1 delay.png](https://raw.githubusercontent.com/GY23333/imgs/master/Network_Congestion-scenario1-delay.png)

## 场景二：2个Sender, 和1个有限buffer的Router

路由器缓存的容量是有限的，当分组到达一个已满的缓存时会被丢弃。

如果一个包含有运输层报文段的分组在路由器中被丢弃，那么它将被发送方重传。

![image-20231117111929705](C:\Users\nightgoodl\AppData\Roaming\Typora\typora-user-images\image-20231117111929705.png)



运输层向网络中发送报文段（含有初始数据或重传数据）的速率用λ'in字节/秒表示。λ'in有时被称为网络的**供给载荷**`（offeredload）`

![image-20231117105339590](C:\Users\nightgoodl\AppData\Roaming\Typora\typora-user-images\image-20231117105339590.png)

a) 主机A能够以某种方式（不可思议地！）确定路由器中的缓存是否空闲，因而仅当缓存空闲时才发送一个分组。在这种情况下，将不会产生丢包，λ'in与λin相等，并且连接的吞吐量就等于λin。

b) 发送方仅当在确定了一个分组已经丢失时才重传。当router的buffer满了，packet丢失,sender只有在确定丢包时才重传。

c) 发送方也许会提前发生超时并重传在队列中已被推迟 但还未丢失的分组。此时，初始数据分组和重传分组都可能到达接收方，但接收方只需要一份这样的分组副本就行了，重传分组将被丢弃。每个packet发两次，吞吐量等于供给载荷的一半。

## 场景三：4个Sender和多个有限buffer的Router及多跳路径

有4台主机发送分组，每台都通过交叠的两跳路径传输

![image-20231117111315060](C:\Users\nightgoodl\AppData\Roaming\Typora\typora-user-images\image-20231117111315060.png)

对于较小的λin，λin的增大会导致吞吐量的增大。（buffer溢出较少）

λin很大时，当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了。

![image-20231117111858182](C:\Users\nightgoodl\AppData\Roaming\Typora\typora-user-images\image-20231117111858182.png)

## 拥塞控制方法

**端到端拥塞控制：**在端到端拥塞控制方法中，网络层没有为运输层拥塞控制提供显式支持。即使网络中存在拥塞，端系统也必须通过对网络行为的观察（如分组丢失与时延）来推断之。

**网络辅助的拥塞控制：**在网络辅助的拥塞控制中，路由器向发送方提供关于网络中拥塞状态的显式反馈信息。

# TCP拥塞控制

## 概述

TCP所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率。

### **TCP发送方如何限制向其连接发送流量**：

运行在发送方的TCP拥塞控制机制跟踪一个额外的变量，即拥塞窗口（congestion window），表示为`cwnd`。它对一个TCP发送方能向网络中发送流量的速率进行了限制。

`rwnd` 是 TCP 协议中用来表示接收窗口大小（Receive Window Size）的参数。接收窗口是接收方用来通知发送方可以发送多少数据而不必等待确认的一种机制，它允许在一个 TCP 连接中的发送和接收方之间实现流量控制。 

### **TCP发送方如何感知在它与目的地之间的路径上出现了拥塞**：

将一个TCP发送方的“丢包事件”定义为：要么出现超时，要么收到来自接收方的3 个冗余ACK。

当出现过度的拥塞时，在沿着这条路径上的一台（或多台）路由器的缓存会溢出，引起一个数据报（包含一个TCP报文段）被丢弃。丢弃的数据报接着会引起发送方的丢包事件（要么超时或收到3个冗余ACK）,发送方就认为在发送方到接收方的路径上出现了拥塞的指示。

### **TCP发送方怎样确定它应当发送的速率**：

一个丢失的报文段表意味着拥塞，因此当丢失报文段时应当降低TCP发送方的速率

一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此当对先前未确认报文段的确认到达时，能够增加发送方的速率

带宽检测：给定ACK指示源到目的地路径无拥塞，而丢包事件指示路径拥塞，TCP调节其传输速率的策略是增加其速率以响应到达的ACK,除非岀现丢包事件，此时才减小传输速率。因此为探测拥塞开始出现的速率，TCP发送方增加它的传输速率，从该速率后退，进而再次开始探测，看看拥塞开始速率是否发生了变化。

**TCP发送速率（TCP sending rate）**

发送`cwnd bytes`，等待1个RTT接收ACK，然后再发送后续的bytes。

`rate≈cwnd/RTT （bytes/sec）`

## TCP拥塞控制算法

参考文章[https://www.cnblogs.com/tuyang1129/p/12439862.html]

### TCP慢启动（TCP slow start）

TCP慢启动是一种TCP拥塞控制的方法，它的目的是避免发送方发送过多的数据导致网络拥塞。慢启动的基本思想是，发送方在开始传输数据时，只发送一个报文段，**然后每收到一个确认，就将拥塞窗口（`cwnd`）增加一个报文段**，这样每个往返时间（`RTT`）拥塞窗口就会翻倍，呈指数增长。当拥塞窗口达到一个阈值（`ssthresh`）或者发生数据丢失时，慢启动就会停止，进入拥塞避免或者快速恢复阶段。拥塞避免和快速恢复是两种不同的算法，它们的区别在于如何处理数据丢失的情况。拥塞避免是在没有丢失的情况下，让拥塞窗口缓慢地线性增长，而快速恢复是在发生丢失后，快速地恢复拥塞窗口的大小，避免重新进入慢启动。

![TCP slow start.png](https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-slow-start.png)

- **`MSS`**：最大报文段长度，`TCP`双方发送的报文段中，包含的数据部分的最大字节数；
- **`cwnd`**：拥塞窗口，`TCP`发送但还没有得到确认的报文的序号都在这个区间；
- **`RTT`**：往返时间，发送方发送一个报文，到接收这个报文的确认报文所经历的时间；
- **`ssthresh`**：慢启动阈值，慢启动阶段，若`cwnd`的大小达到这个值，将转换到拥塞避免模式；

**慢启动结束情况：**

- 第一种：若在慢启动的过程中，发生了数据传输超时，则此时`TCP`将`ssthresh`的值设置为`cwnd / 2`，然后将`cwnd`重新设置为`1MSS`，重新开始慢启动过程，这个过程可以理解为试探上限；
- 第二种：第一步试探出来的上限`ssthresh`将用在此处。若`cwnd`的值增加到`>= ssthresh`时，此时若继续使用慢启动的翻倍增长方式可能有些鲁莽，所以这个时候结束慢启动，改为拥塞避免模式；
- 第三种：若发送方接收到了某个报文的三次冗余确认（即触发了快速重传的条件），则进入到快速恢复阶段；同时，`ssthresh = cwnd / 2`，毕竟发生快速重传也可以认为是发生拥塞导致的丢包，然后`cwnd = ssthresh + 3MSS`；

**慢启动结束第三种情况分析**：

这是一个很好的问题，关于TCP慢启动时的拥塞控制策略。我会尝试从以下几个方面来解释：

当发送方连续收到三个重复的确认（冗余ACK）时，就认为网络发生了拥塞，因为这意味着有一个报文段丢失或者乱序到达了接收方。这时，发送方就要执行“乘法减小”算法，把`ssthresh`设置为当前`cwnd`的一半，以降低发送速率。

当发送方收到三个重复的确认时，除了降低`ssthresh`，还要立即重传丢失的报文段，这就是快速重传的机制。

当发送方重传丢失的报文段后，不是重新进入慢启动阶段，而是进入快速恢复阶段。这是因为发送方认为网络没有发生严重的拥塞，而是由于某些原因导致的报文段丢失或乱序。因此，发送方不需要把`cwnd`重新设置为1，而是把`cwnd`设置为`ssthresh`加上3个报文段的大小，然后开始执行拥塞避免算法，让`cwnd`缓慢地线性增长。

为什么要把`cwnd`设置为`ssthresh`加上3个报文段的大小呢？这是因为既然发送方收到了三个重复的确认，就说明有三个报文段已经离开了网络，不会占用网络资源。因此，发送方可以增加`cwnd`的大小，以充分利用网络的带宽。\

### 拥塞避免

刚进入这个模式时，`cwnd`的大小近似的等于上次拥塞时的值的一半（这是由进入这个模式的条件决定的），也就是说当前的`cwnd`比较接近产生拥塞的值。所以，**拥塞避免是一个速率缓慢且线性增长的过程**，在这个模式下，**每经历一个`RTT`，`cwnd`的大小增加`1MSS`**，也就是说，如果MSS是1460字节并且`cwnd`是14600字节，则在一个RTT内发送10个报文段。每个到达ACK（假定每个报文段一个ACK）增加1/10MSS的拥塞窗口长度，因此在收到对所有10个报文段的确认后，拥塞窗口的值将增加了一个MSS。

这个线性增长的过程什么时候结束，分为两种情况：

- 第一种：在这个过程中，发生了超时，则表示网络拥塞，这时候，`ssthresh`被修改为`cwnd / 2`，然后`cwnd`被置为`1MSS`，并进入慢启动阶段；
- 第二种：若发送方接收到了某个报文的三次冗余确认（即触发了快速重传的条件），此时也认为发生了拥塞，则，`ssthresh` 被修改为 `cwnd / 2`，然后`cwnd`被置为`ssthresh + 3MSS`，并进入快速恢复模式；

  我们可以看到，慢启动和拥塞避免在接收到三个冗余的确认报文时，处理方式是一样的：判断发生了拥塞，并减小`ssthresh`的大小，但是`cwnd`的大小却不见得有减小多少，这一点让人疑惑。虽然发送方通过接收三次冗余确认报文，判断可能存在拥塞，但是既然可以收到冗余的确认报文，表示拥塞不会太严重，甚至已经不再拥塞，所以对`cwnd`的减小不是这么剧烈。

### 快速恢复

在快速恢复阶段，每接收到一个冗余的确认报文，`cwnd`就增加`1MSS`，其余不变，而当发生以下两种情况时，将退出快速恢复模式：

- 第一种：在快速恢复过程中，计时器超时，这时候，`ssthresh`被修改为 `cwnd / 2`，然后`cwnd`被置为`1MSS`，并进入慢启动阶段；
- 第二种：若发送方接收到一条新的确认报文（不是冗余确认），则`cwnd`被置为`ssthresh`，然后进入到拥塞避免模式；

进入到此模式的条件就是接收到三次冗余的确认报文，判断报文丢失，那为什么再次接收到冗余确认报文时，`cwnd`还是要增长呢？

此时再次收到一条冗余的确认报文，表示发送端发出的报文又有一条离开网络到达了接收端（虽然不是接收端当前想要的一条），这说明网络中腾出了一条报文的空间，所以允许发送端再向网络中发送一条报文。但是由于当前序号最小的报文丢失，导致拥塞窗口`cwnd`无法向前移动，于是只好将`cwnd`增加`1MSS`，于是发送端又可以发送一条数据段，提高了网络的利用率。

### TCP拥塞控制FSM

![TCP congestion control.png](https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-congestion-control.png)

### TCP吞吐量

有一个简单的公式可以用来估计TCP的最大吞吐量，即TCP窗口大小除以往返延迟。这个公式的含义是，发送方在得到接收方的确认之前，可以发送的最大数据量。如果TCP窗口大小或往返延迟变化，TCP的吞吐量也会相应地变化。例如，如果TCP窗口大小是64 KB，往返延迟是`100 ms`，那么TCP的最大吞吐量是640 KB/s。如果TCP窗口大小增加到128 KB，往返延迟不变，那么TCP的最大吞吐量就增加到1280 KB/s。如果TCP窗口大小不变，往返延迟增加到`200 ms`，那么TCP的最大吞吐量就降低到320 KB/s。

### 高速TCP

高速TCP是一种TCP拥塞控制的算法，它的目的是在高带宽和高延迟的网络中提高TCP的吞吐量和效率。高速TCP的基本思想是，根据当前的拥塞窗口大小和丢包率，动态地调整拥塞窗口的增加和减少的参数，使得拥塞窗口能够更快地适应网络的状况，避免过度拥塞或者过度保守。它是一种基于丢包反馈的协议，也就是说，它只有在发生数据丢失时才会降低发送速度，否则就会不断增加发送速度，以充分利用网络的剩余带宽。

高速TCP的优点是，它能够在高速网络中更好地利用带宽，提高网络的性能，同时也能保持与标准TCP的兼容性和公平性。高速TCP的缺点是，它可能在一些特殊的网络环境中表现不佳，例如在有多个分组从同一个数据窗口丢失的情况下，或者在有较大的RTT变化的情况下，或者在有较多的UDP流的情况下。

### Explicit Congestion Notification（ECN）

- `ToS field`（IP datagram头部的 2 bits）可以被网络路由标记，以显示拥塞
- `ToS field`会被送到receiver的主机
- receiver在发送给sender的ACK中嵌入ECE，来通知sender有拥塞

![TCP ECN.png](https://raw.githubusercontent.com/GY23333/imgs/master/Network_TCP-ECN.png)