# 网络层：控制平面

## 路由选择算法

### 维护转发表

每台路由器的**数据平面**要解决从输入链路向输出链路转发数据报的问题，**控制平面**要些协调这些路由器的转发动作，使得数据报沿着源和目的主机间的路由器最短路径进行端到端传输。对于转发表和流表的计算、维护和安装，有 2 种手法可以实现。

#### 每路由器控制

这是传统的方法，每台路由器都包含转发和路由选择的功能。每台路由器都有一个路由选择组件，用于与其它路由器中的路由选择组件通信，OSPF 和 BGP 协议都是基于这种手法实现的。
[![img](https://img2020.cnblogs.com/blog/1774310/202006/1774310-20200602152648530-1259548228.png)](https://img2020.cnblogs.com/blog/1774310/202006/1774310-20200602152648530-1259548228.png)

#### 逻辑集中式控制

SDN 方法，控制平面的路由选择功能和物理的路由器是分离的，由路由选择设备执行转发，**远程控制器**计算并分发转发表。远程控制器可能实现在具有高可靠性和冗余的远程数据中心中，可能有 ISP 或某些第三方管理。控制器通过协议和每台路由器中的控制代理(CA)进行交互，以此配置该路由器的转发表。CA 的任务是与控制器通信并按照控制器的命令执行。
SDN 技术使用了逻辑集中式控制器的概念，这种方法在现在的生产部署中得到越来越多的应用。
[![img](https://img2020.cnblogs.com/blog/1774310/202006/1774310-20200602152848083-64312783.png)](https://img2020.cnblogs.com/blog/1774310/202006/1774310-20200602152848083-64312783.png)

### 路由选择算法的分类

对于路由选择问题，我们可以简单地将情景抽象为一个图结构，每一个路由器抽象为顶点，路由器之间抽象为边。
路由选择算法可以从发送方到接收方中确定一条通过路由器的较好的路径，通常来说是**最低开销**的路径。对于最短路径的分类方式，有 3 种典型的讲法。
[![img](https://img2020.cnblogs.com/blog/1774310/202006/1774310-20200602154812348-813497100.png)](https://img2020.cnblogs.com/blog/1774310/202006/1774310-20200602154812348-813497100.png)

#### 集中或分散

**集中式路由选择算法**用完整的、全局性的网络知识计算出从源到目的地之间的最低开销，这就要求算法在开始运作前获得顶点间的连通性和链路开销。算法的运作既可以在类似于逻辑集中式控制器这种某一设备中进行，也可以在每台路由器的路由选择组件中进行。
与之相对应的是**分散式路由选择算法**，路由器以**迭代、分布式**的方式计算出最低开销路径。这类算法的特点是，没有任何结点拥有关于网络链路开销的完整信息，每个结点仅有与其直接相连的链路的开销知识就可以开始工作。通过迭代就先以及相邻结点的信息交换，节点逐渐计算出达到目的节点的最低开销路径。

#### 静态或动态

静态路由选择算法路由随着时间变化非常缓慢，通常是人工进行调整。动态路由选择算法随着网络流量负载或拓扑发生变化而改变路由选择路径。虽然动态路由选择算法可以很快获取网络的变化，但是容易受到选择循环、路由震荡等问题影响。

#### 负载敏感或迟钝

负载敏感算法中的链路，会动态地变化以反映底层链路的拥塞水平。但是某条链路的开销并不能明确地反映当前的拥塞水平，因此当今因特网使用的路由选择算法都是**负载迟钝**的。

### 链路状态路由选择算法(LS 算法)

#### 算法原理

LS 算法中，网络拓扑和所有链路开销都已知，在实践中可以使用**链路状态广播**算法来完成，通过结点广播就可以使所有结点得到该网络完整的、统一的视图。该算法的内部实现就是我们熟知的 **Dijkstra 算法**。
对于 Dijkstra 算法可以使用**堆结构**对其进行强化，使其时间复杂度缩小到 **`O(nlogn)`**。

#### 振荡问题

链路状态路由选择算法（LS 算法）是一种动态路由算法，它的工作原理是每个路由器将自己的链路状态信息洪泛（flooding）到网络上的所有路由器，然后每个路由器使用最短路径算法计算最短路径，来更新路由表。

链路状态路由选择算法的一个问题是可能出现**路由震荡**（oscillations），即**路由器在不同的状态之间反复切换**，导致网络不稳定。路由震荡的原因是**链路的代价具有方向性**，即从 A 到 B 的代价和从 B 到 A 的代价不一定相等。这样，当路由器选择了一个方向的路由后，可能**会影响链路的拥塞程度**，从而改变链路的权重，进而导致另一个方向的路由更优，形成震荡。

路由震荡的解决方法有以下几种：

- 使用多区域，将网络划分为不同的区域，**减小路由域的规模**，降低路由更新的频率和范围。
- 使用路由汇总，将多条路由合并为一条路由，减少路由表的条目，降低路由变化的影响。
- 使用**惩罚机制**，对频繁震荡的路由进行惩罚，使其暂时不可用，直到其稳定后，才可重新使用。



> 路由汇总又被称为路由聚合，是将一组有规律的路由汇聚成一条路由，从而达到减小路由表规模的以及优化设备资源利用率的目的，我们把汇聚前的这组路由称为精细路由或明细路由，把汇聚后的路由称为汇总路由或聚合路由。



# 距离向量路由选择算法(DV 算法)[#](https://www.cnblogs.com/linfangnan/p/13031627.html#1960808158)

## 算法特点[#](https://www.cnblogs.com/linfangnan/p/13031627.html#242925371)

LS 算法我们是比较熟悉的，下面就来详细谈一下**距离向量(DV)** 算法。相比于 LS 算法需要有网络的全局信息，DV 算法是一种迭代、异步和分布式的算法。**分布式**体现于算法的流程，是要每个结点都从一个或多个直接连接的邻居接收信息，通过对信息的计算，再把结果通告给邻居。**迭代**体现于算法对于上述的过程，需要一直持续到邻居之间没有信息需要交换位置。**异步**体现于不需要所有的节点统一进行操作，而是当收到邻居发来的信息进行操作即可。

## Bellman-Ford 方程[#](https://www.cnblogs.com/linfangnan/p/13031627.html#3099597906)

DV 算法的原理使用了 Bellman-Ford 方程，具体内容如下。结合我们的情景讲一下每个参数，“c(x,v)” 表示 x 到邻居 v 的开销，dv(y) 表示从邻居 v 到目的地 y 的开销，我们需要在 x 的所有邻居中获得最小值。

> dx(y) = minv{c(x,v) + dv(y)}

Bellman-Ford 方程为 DV 算法的与邻居的通信提供了理论基础。简单地说，也就是结点获得最短路径的下一跳，并且将该信息写入转发表中。这时我们也给出距离向量的定义，向量所表示的信息是 x 在 N 中到其他所有结点 y 的开销估计向量。

> Dx = [Dy: y ∈ N]

## 算法实现[#](https://www.cnblogs.com/linfangnan/p/13031627.html#3549033878)

DV 算法对于一个节点 x 来说，当 x 发现与它直接连接的链路开销发生变化或从邻居接收到一个距离向量的更新时，重新计算距离向量的估计值，若最低开销路径发生了变化，就像邻居发送新的距离向量。具体怎么实现，通过一个例子来说明：
[![img](https://img2020.cnblogs.com/blog/1774310/202006/1774310-20200602182850049-1813519491.png)](https://img2020.cnblogs.com/blog/1774310/202006/1774310-20200602182850049-1813519491.png)
我们有一个简单的网络拓扑，有 v,y,z 3 个节点，下图中最左边就是 3 个节点的初始路由表。如图展示的就是根据 DV 算法更新路由表的过程。
[![img](https://img2020.cnblogs.com/blog/1774310/202006/1774310-20200602183309013-1498022940.png)](https://img2020.cnblogs.com/blog/1774310/202006/1774310-20200602183309013-1498022940.png)

# DV 算法故障分析[#](https://www.cnblogs.com/linfangnan/p/13031627.html#2771359681)

## 好消息，传播快！[#](https://www.cnblogs.com/linfangnan/p/13031627.html#2309672031)

下面我们看一个情景，如图哦所示 y->x 的链路开销由 4 变为 1，表示这条链路的最低开销发生变化。首先是 y 发现了开销变化，就更新自己的距离向量并通知 z。z 接收到了 y 的信息之后重新计算到 x 的开销(5->2)，并发送消息给 y。下一步 y 的最低开销不变，因此算法进入静止状态。
我们可以看到 DV 算法最终将收敛于一个最佳状态，同时也可以看出对于网络状态变得更好时，最低开销的传播速度是很快的。
[![img](https://img2020.cnblogs.com/blog/1774310/202006/1774310-20200602202631077-775655795.png)](https://img2020.cnblogs.com/blog/1774310/202006/1774310-20200602202631077-775655795.png)

## 无穷计数[#](https://www.cnblogs.com/linfangnan/p/13031627.html#3953241323)

下面再看一个网络状态变拥塞的例子，还是如图所示，这次 y->x 的链路开销由 4 变为 60。
[![img](https://img2020.cnblogs.com/blog/1774310/202006/1774310-20200602203336144-1456539086.png)](https://img2020.cnblogs.com/blog/1774310/202006/1774310-20200602203336144-1456539086.png)
那么距离向量是怎么计算的呢？此时在链路开销变化前，Dy(x) = 4，Dy(z) = 1，Dz(y) = 1，Dz(x) = 5，而发生变化的信息是 c(y,x) = 60，根据这些信息计算出来的距离向量如下：

> Dy(x) = min{c(y,x) + Dx(x)，c(y,z) + Dz(x)} = min{60 + 0，1 + 5} = 6

此时计算出来的路径是 y->z->x，而开销是 6，结合这张图来看很明显是错误的，而此时 y 又会将错误的信息传递给 z，z 到 x 的距离向量的计算为：

> Dz(x) = min{c(z,x) + Dx(x)，c(z,y) + Dy(x)} = min{50 + 0，1 + 6} = 7

此时再次得到了错误的信息，而且这个还会被传播给 y，这个时候就遇到了**选择环路**，即 y 和 z 将会不停地更新转发表直到发现了 y->x 的链路出现故障。这样的开销无疑是很大的，这也体现出了 DV 算法“**坏消息，传播慢！”的特点。

| 时间  | y->x  | z->x  | 转发信息         |
| ----- | ----- | ----- | ---------------- |
| t0    | 6     | 5     | y->z：Dy(x) = 6  |
| t1    | 6     | 7     | z->y：Dz(x) = 7  |
| t2    | 8     | 7     | y->z：Dy(x) = 8  |
| t3    | 8     | 9     | z->y：Dz(x) = 9  |
| t4    | 10    | 9     | y->z：Dy(x) = 10 |
| **…** | **…** | **…** | **…**            |

对于路由器彼此之间认为对方可到达而出现环路的情况，我们称之为**无穷计数**。

## 毒性逆转[#](https://www.cnblogs.com/linfangnan/p/13031627.html#3751211905)

对于上述的“无穷计数”故障，可以使用名为“**毒性逆转**”的手法规避。这种手法的思想是若一个结点到某目的的最小开销路径需要通过某个邻居，则通告给该邻居节点到达目的的开销为 ∞。
[![img](https://img2020.cnblogs.com/blog/1774310/202006/1774310-20200602203336144-1456539086.png)](https://img2020.cnblogs.com/blog/1774310/202006/1774310-20200602203336144-1456539086.png)
还是刚才的例子，此时我们观察一下无穷计数故障是否被规避了。发生变化的信息是 c(y,x) = 60，而此时在上一次 z 传递给 y 的 **Dz(x) = ∞**。

| 时间 | y->x | z->x | 转发信息            |
| ---- | ---- | ---- | ------------------- |
| t0   | 60   | 5    | y->z：Dy(x) = 60    |
| t1   | 60   | 50   | z->y：Dz(x) = 50    |
| t2   | 51   | 50   | y->z：**Dy(x) = ∞** |
| t3   | 51   | 50   | NULL                |

由此可见，毒性逆转消除了这个故障，请问毒性逆转**能够完全解决无穷计数的问题吗**？

# LS 算法 VS DV 算法[#](https://www.cnblogs.com/linfangnan/p/13031627.html#526771379)

2 种算法采取不同的思路来得出最短路径，这 2 种算法在以下 3 个方面有着很明显的不同。

## 报文复杂性[#](https://www.cnblogs.com/linfangnan/p/13031627.html#507195163)

LS 算法需要知道网络中所有链路的开销，这就需要发送足够多的(O(|N||E|))报文才能获取，当任何一条链路开销发生改变时，也必须向所有的节点发送新的开销信息。而 DV 算法在每次迭代时，只需要 2 个直接相连的邻居交换报文即可。

## 收敛速度[#](https://www.cnblogs.com/linfangnan/p/13031627.html#307487575)

LS 算法的时间复杂度和我们熟悉的 Dijkstra 算法相同，但是会遇到振荡问题，而 DV 算法也会遇到麻烦的无穷计数问题。

## 健壮性[#](https://www.cnblogs.com/linfangnan/p/13031627.html#847988909)

若网络中突然出现某台路由器故障、系统错乱或被蓄意破坏的情况。对于 LS 算法由于路由的计算时分离的，因此路由器可以向其连接的链路广播异常状态。对于 DV 算法来说，当产生了不正确的最低开销的计算结果，这个错误将会蔓延到整个网络。

## OSPF算法



## BGP算法



## SDN控制平面



## 网络管理和SNMP